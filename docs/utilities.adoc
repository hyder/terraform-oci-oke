= Cluster extensions
:idprefix:
:idseparator: -
:sectlinks:
:toc: auto

:uri-oci-authtoken: https://docs.cloud.oracle.com/iaas/Content/Registry/Tasks/registrygettingauthtoken.htm
:uri-oci-secret: https://docs.cloud.oracle.com/en-us/iaas/Content/KeyManagement/Tasks/managingsecrets.htm

== OCIR

NOTE: TODO Pending validation in 5.x

The {uri-oci-authtoken}#[Auth Token] must first be manually created and stored in {uri-oci-secret}#[OCI Secret in Vault]. It will subsequently be used to create a Kubernetes secret, which can then be used as an imagePullSecrets in a deployment. If you do not need to use private OCIR repositories, then leave the *secret_id* parameter empty. Refer to the {uri-instructions}#creating-a-secret-for-ocir[instructions] for how to create the Auth Token and the Secret in Vault.

The secret is created in the "default" namespace. To copy it to your namespace, use the following command:

----
kubectl --namespace=default get secret ocirsecret --export -o yaml | kubectl apply --namespace=<newnamespace> -f -
----

=== Creating a Secret

{uri-oci-ocir}[Oracle Cloud Infrastructure Registry] is a highly available private container registry service for storing and sharing container images within the same regions as the OKE Cluster. Use the following rules to determine if you need to create a Kubernetes Secret for OCIR:

* If your container repository is public, you do not need to create a secret. 
* If your container repository is private, you need to create a secret before OKE can pull your images from the private repository. 

If you plan on creating a Kubernetes Secret for OCIR, you must first {uri-oci-authtoken}[create an Auth Token]. Copy and temporarily save the value of the Auth Token.

You must then {uri-oci-secret}[create a Secret in OCI Vault to store] the value of the Auth Token in it. 

Finally, assign the Secret OCID to *secret_id* in terraform.tfvars. Refer to {uri-terraform-options}#ocir[OCIR parameters] for other parameters to be set.

NOTE: Installing the Vertical Pod Autoscaler also requires installing the Metrics Server, so you need to enable that too.


[stripes=odd,cols="1m,4d,2m,2m", options=header,width="100%"]
|===
|Parameter
|Description
|Values
|Default

|email_address
|The email address to be used when creating the Docker secret. *Required* if secret_id is set.
|
|none

|secret_id
|The id of the Secret in Vault where the Auth Token is stored.
|
|none

|secret_name
|Secret name in Kubernetes that will hold the authentication token
|
|ocirsecret

|secret_namespace
|The Kubernetes namespace for where the OCIR secret will be created
|
|default

|username
|The username that can login to the selected tenancy. This is different from tenancy_id. *Required* if secret_id is set.
|
|none

|===

== Service account

NOTE: TODO Pending validation in 5.x

OKE now uses Kubeconfig v2 which means the default token has a limited lifespan. In order to allow CI/CD tools to deploy to OKE, a service account must be created.

.Set the *create_service_account = true* and you can name the other parameters as appropriate:
----
create_service_account = true
service_account_name = "kubeconfigsa"
service_account_namespace = "kube-system"
service_account_cluster_role_binding = ""
----

[stripes=odd,cols="1m,4d,2m,2m", options=header,width="100%"]
|===
|Parameter
|Description
|Values
|Default

|create_service_account
|Whether to create a service account. A service account is required for CI/CD. See https://docs.cloud.oracle.com/iaas/Content/ContEng/Tasks/contengaddingserviceaccttoken.htm
|true/false
|false

|service_account_name
|The name of service account to create
|
|kubeconfigsa

|service_account_namespace
|The Kubernetes namespace where to create the service account
|
|kube-system

|service_account_cluster_role_binding
|The name of the cluster role binding for the service account
|
|

|===

== OKE Load Balancers

[stripes=odd,cols="1m,4d,2m,2m", options=header,width="100%"]
|===
|Parameter
|Description
|Values
|Default

|load_balancers
|The type of load balancer subnets to create.

Even if you set the load balancer subnets to be internal, you still need to set the correct {uri-oci-loadbalancer-annotations}[annotations] when creating internal load balancers. Just setting this value to internal is *_not_* sufficient.

Refer to {uri-topology}[topology] for more thorough examples.
|both, internal, public
|public

|preferred_load_balancer
|The preferred load balancer subnets that OKE will automatically choose when creating load balancers. If 'public' is chosen, the value for load_balancers must be either 'public' or 'both'. If 'private' is chosen, the value for load_balancers must be either 'internal' or 'both'.

Even if you set the load balancer subnets to be internal, you still need to set the correct {uri-oci-loadbalancer-annotations}[annotations] when creating internal load balancers. Just setting the subnet to be private is *_not_* sufficient.

Refer to {uri-topology}[topology] for more thorough examples.

|internal/public
|public

|internal_lb_allowed_cidrs
|The list of CIDR blocks from which the internal load balancer can be accessed.
|`e.g.: ["0.0.0.0/0"]
|`["0.0.0.0/0"]`

|internal_lb_allowed_ports
|List of allowed ports for internal load balancers.
|e.g.: `[80, 443]`
|`[80, 443]`

|public_lb_allowed_cidrs
|The list of CIDR blocks from which the public load balancer can be accessed.
|e.g.: `["0.0.0.0/0"]`
|`["0.0.0.0/0"]`

|public_lb_allowed_ports
|List of allowed ports for public load balancers.
|e.g.: `[443]`
|`[443]`

|===
